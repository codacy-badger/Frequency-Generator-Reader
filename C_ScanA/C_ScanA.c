/*
  File Name: C_ScanA.c
  Project: Currently Unnamed

  Company: Research in Flows, Inc
  Author: David Gurevich

   This work is licensed under the Creative Commons
  Attribution-NonCommercial-NoDerivs 3.0 Unported License.
       To view a copy of this license, visit
  http://creativecommons.org/licenses/by-nc-nd/3.0/ or send a letter to
       Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

  Dependencies:
    - cbw.h
    - cbw32.lib
    - cbw64.lib

  Purpose:
      This software reads the count and the rate generated by Main.py
  'config.txt' to determine
    the number of points to measure, and at what rate to measure them.
      This software runs an analyzer on Board 1, and gets x many Analog input
  values.
    It is kept in a Windows Buffer, and then one by one, exported into a file
  'output.txt'
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include "cbw.h"

void scan_a_in(long count, long rate, int scanType) {
  int BoardNum = 0;
  int ULStat = 0;
  int LowChan = 0;
  int HighChan = 0;
  int Gain = scanType;
  long Count = count;
  long Rate = rate;

  double engUnitOutput;
  int inputDetected = 0;

  HANDLE MemHandle = 0;
  WORD *ADData = NULL;
  DWORD *ADData32 = NULL;

  unsigned Options;
  float RevLevel = (float)CURRENTREVNUM;
  BOOL HighResAD = FALSE;
  int ADRes;

  FILE *fOutput;
  FILE *fVoltageOutput;

  ULStat = cbDeclareRevision(&RevLevel);

  cbErrHandling(PRINTALL, STOPALL);
  cbGetConfig(BOARDINFO, BoardNum, 0, BIADRES, &ADRes);

  if (ADRes > 16) {
    HighResAD = TRUE;
  }

  if (HighResAD) {
    MemHandle = cbWinBufAlloc32(Count);
    ADData32 = (DWORD *)MemHandle;
  } else {
    MemHandle = cbWinBufAlloc(Count);
    ADData = (WORD *)MemHandle;
  }

  if (!MemHandle) {
    printf("\nOut Of Memory\n");
    exit(1);
  }

  Options = CONVERTDATA + BURSTIO;

  ULStat = cbAInScan(BoardNum, LowChan, HighChan, Count, &Rate, Gain, MemHandle,
                     Options);
  for (int j = 0; j < Count; j++) {
    if (ADData[j] != 0 || ADData[j] != 4095) {
      inputDetected = 1;
      break;
    }
  }

  if (inputDetected == 1) {
    printf("Scan Complete! \n");

    fOutput = fopen("Output/output.txt", "w+");
    fVoltageOutput = fopen("Output/voltage output.txt", "w+");

    printf("Writing results to file...\n");

    for (int i = 0; i < Count; i++) {
      fprintf(fOutput, "%4u\n", ADData[i]);

      cbToEngUnits32(BoardNum, Gain, ADData[i], &engUnitOutput);
      fprintf(fVoltageOutput, "%.8f\n", engUnitOutput);

      int percentage = ((double)i / (int)Count) * 100;
      printf("\r%d / %ld --- %d%%", i, Count, percentage);
    }

    printf("\nWrite Complete!\n");
    fclose(fOutput);
    fclose(fVoltageOutput);
  } else {
    printf("Scan Failed!\n");
  }

  cbWinBufFree(MemHandle);
}

int main() {
  FILE *fp;
  fp = fopen("Output/config.txt", "r");

  char char_count[150];
  fgets(char_count, 150, fp);

  char rate_count[150];
  fgets(rate_count, 150, fp);

  char scan_type[5];
  fgets(scan_type, 5, fp);

  fclose(fp);

  int count, rate, type;

  sscanf(char_count, "%d", &count);
  sscanf(rate_count, "%d", &rate);
  sscanf(scan_type, "%d", &type);

  scan_a_in(count, rate, type);
  return 0;
}
